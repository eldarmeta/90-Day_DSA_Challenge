Roadmap: 90-Day DSA Challenge (Easy to Advanced)

Overview: This 90-day roadmap will guide you through daily problem-solving practice, covering fundamental to advanced topics in data structures and algorithms (DSA). It is structured by weeks, each focusing on a core topic (Arrays, Strings, Linked Lists, etc.), with a brief theoretical overview followed by 3 daily coding challenges. The plan starts with easy problems in month 1, moves to intermediate problems in month 2, and tackles advanced problems in month 3. This progression mirrors the typical categories of programming contests â€“ including arrays, data structures, combinatorics, number theory, graphs, dynamic programming, and more ï¿¼. By steadily increasing difficulty, you will build a strong algorithmic foundation from scratch (0) to a â€œgoodâ€ level.

How to use this roadmap: Each week, read the short theory notes to understand key concepts (with a focus on Java implementations when relevant), then solve the listed problems (with links) â€“ 3 problems per day. The tasks are curated from LeetCode (interview-style questions), CodeForces (competitive programming puzzles), and other platforms. Keep track of your progress in a notebook or journal, and commit your solutions (e.g. to GitHub) for consistency and contribution. By the end of 90 days, you will have practiced a broad range of important problems in computer science and discrete mathematics, in Java and general algorithmic contexts.

Note: Itâ€™s normal if you find some problems challenging â€“ the difficulty increases gradually. Use the theory notes and hints from similar problems to guide you. Consistency is key (3 problems a day), and you can adjust pacing if needed. Now, letâ€™s dive into the weekly breakdown of topics and problems!

Week 1 (Days 1â€“7): Arrays ğŸ“‹ (Fundamentals â€“ Easy Level)

Theory (Arrays): Arrays are one of the most widely used data structures and a fundamental building block in programming ï¿¼. An array stores elements in contiguous memory locations, allowing constant-time access by index. Key operations include traversal, updating values, and searching. In Java, arrays have fixed size, but you can use ArrayList for dynamic resizing. Important concepts involve iterating through arrays, using two-pointer techniques for sorted arrays, and basic in-place algorithms. This weekâ€™s problems focus on array manipulation, scanning for specific values or patterns, and simple algorithms (like sorting small arrays or summing subsets). These exercises solidify your understanding of indexing and looping â€“ critical skills before moving to more complex structures.
	â€¢	Day 1: Two Sum (LeetCode), Best Time to Buy and Sell Stock (LeetCodeÂ 121), Contains Duplicate (LeetCodeÂ 217)
	â€¢	Day 2: Maximum Subarray (LeetCodeÂ 53), Rotate Array (LeetCodeÂ 189), Single Number (LeetCodeÂ 136)
	â€¢	Day 3: Intersection of Two Arrays (LeetCodeÂ 349), Move Zeroes (LeetCodeÂ 283), Plus One (LeetCodeÂ 66)
	â€¢	Day 4: Remove Duplicates from Sorted Array (LeetCodeÂ 26), Remove Element (LeetCodeÂ 27), Missing Number (LeetCodeÂ 268)
	â€¢	Day 5: Majority Element (LeetCodeÂ 169), Merge Sorted Array (LeetCodeÂ 88), Find All Numbers Disappeared in an Array (LeetCodeÂ 448)
	â€¢	Day 6: Max Consecutive Ones (LeetCodeÂ 485), Squares of a Sorted Array (LeetCodeÂ 977), Valid Mountain Array (LeetCodeÂ 941)
	â€¢	Day 7: Third Maximum Number (LeetCodeÂ 414), Check If N and Its Double Exist (LeetCodeÂ 1346), Gravity Flip (CodeForcesÂ 405A)

Week 2 (Days 8â€“14): Strings ğŸ“ (Fundamentals â€“ Easy Level)

Theory (Strings): Strings are sequences of characters and are key to handling text data. Common string problems involve searching, parsing, comparing, and modifying strings. In Java, String is immutable (each modification creates a new string), but you can use StringBuilder for efficient edits. Important topics include palindrome checks, anagram detection, and simple parsing. This week covers basic string algorithms: reversing strings, comparing lexicographic order, and character frequency counts. Youâ€™ll practice using hash maps or arrays for frequency (e.g. counting letters for an anagram), two-pointer techniques for palindrome checking, and basic conversions (like integer <-> roman numeral). Mastering strings will prepare you for more complex algorithms, as string manipulation often appears in both interviews and contest problems.
	â€¢	Day 8: Valid Anagram (LeetCodeÂ 242), First Unique Character in a String (LeetCodeÂ 387), Ransom Note (LeetCodeÂ 383)
	â€¢	Day 9: Valid Palindrome (LeetCodeÂ 125), Palindrome Number (LeetCodeÂ 9), Roman to Integer (LeetCodeÂ 13)
	â€¢	Day 10: Longest Common Prefix (LeetCodeÂ 14), Implement strStr() â€“ Substring Search (LeetCodeÂ 28), Add Binary (LeetCodeÂ 67)
	â€¢	Day 11: Reverse String (LeetCodeÂ 344), Reverse Words in a String III (LeetCodeÂ 557), Is Subsequence (LeetCodeÂ 392)
	â€¢	Day 12: Excel Sheet Column Number (LeetCodeÂ 171), Excel Sheet Column Title (LeetCodeÂ 168), Detect Capital (LeetCodeÂ 520)
	â€¢	Day 13: Count and Say (LeetCodeÂ 38), Valid Palindrome II (LeetCodeÂ 680), Check If Two String Arrays are Equivalent (LeetCodeÂ 1662)
	â€¢	Day 14: Reverse Only Letters (LeetCodeÂ 917), Jewels and Stones (LeetCodeÂ 771), Boy or Girl (CodeForcesÂ 236A)

Week 3 (Days 15â€“21): Linked Lists ğŸ”— (Fundamentals â€“ Easy Level)

Theory (Linked Lists): A linked list is a linear data structure where elements (nodes) are linked using pointers. Each node contains data and a reference to the next (and in doubly-linked lists, also to the previous) node. Unlike arrays, linked lists allow efficient insertion/deletion (O(1) at head or tail if you have the pointer) without shifting elements, but random access is not constant time (you must traverse). In Java, you might implement your own Node class or use built-in structures (e.g. LinkedList from java.util, though that is a doubly-linked list). Key operations: reversing a list, detecting cycles (Floydâ€™s cycle algorithm), finding middle or nth-from-end nodes, and merging sorted lists. This weekâ€™s tasks cover these basics and a few intermediate challenges (toward the end of the week) like recursion on lists and more complex reordering. Mastering linked lists will also help with understanding pointers and memory references in general.
	â€¢	Day 15: Merge Two Sorted Lists (LeetCodeÂ 21), Reverse Linked List (LeetCodeÂ 206), Middle of the Linked List (LeetCodeÂ 876)
	â€¢	Day 16: Linked List Cycle (LeetCodeÂ 141), Remove Duplicates from Sorted List (LeetCodeÂ 83), Remove Linked List Elements (LeetCodeÂ 203)
	â€¢	Day 17: Palindrome Linked List (LeetCodeÂ 234), Intersection of Two Linked Lists (LeetCodeÂ 160), Delete Node in a Linked List (LeetCodeÂ 237)
	â€¢	Day 18: Remove Nth Node from End of List (LeetCodeÂ 19), Linked List Cycle II (LeetCodeÂ 142), Odd Even Linked List (LeetCodeÂ 328)
	â€¢	Day 19: Add Two Numbers (LeetCodeÂ 2), Reorder List (LeetCodeÂ 143), Swap Nodes in Pairs (LeetCodeÂ 24)
	â€¢	Day 20: Copy List with Random Pointer (LeetCodeÂ 138), Flatten a Multilevel Doubly Linked List (LeetCodeÂ 430), Rotate List (LeetCodeÂ 61)
	â€¢	Day 21: Remove Duplicates from Sorted List II (LeetCodeÂ 82), Partition List (LeetCodeÂ 86), Split Linked List in Parts (LeetCodeÂ 725)

Week 4 (Days 22â€“28): Hash Tables & Sets ğŸ—ƒï¸ (Fundamentals â€“ Easy Level)

Theory (Hash Tables/Sets): A hash table (or hash map) stores key-value pairs for efficient lookup (average O(1) time). A hash set is a related structure that stores unique keys (like a mathematical set). In Java, use HashMap<K,V> and HashSet classes. Hash tables are extremely versatile â€“ they allow quick checks for existence of an element, counting frequencies, caching computed results, etc. Common patterns include using a map to count occurrences (for frequency analysis), to map one value to another (e.g. mapping characters for an anagram or pattern), or to detect duplicates efficiently. This weekâ€™s problems include classic hashing tasks: detecting sums with complements, finding frequency of elements, identifying common elements between collections, and simple design of hash data structures. By solving these, you learn to trade space for time and use hashing to simplify problems. (Note: Hashing is a common tool in algorithm optimization and appears in many interview problems ï¿¼.)
	â€¢	Day 22: Happy Number (LeetCodeÂ 202), Isomorphic Strings (LeetCodeÂ 205), Word Pattern (LeetCodeÂ 290)
	â€¢	Day 23: Contains Duplicate II (LeetCodeÂ 219), Minimum Index Sum of Two Lists (LeetCodeÂ 599), Two Sum II â€“ Input Array is Sorted (LeetCodeÂ 167)
	â€¢	Day 24: Group Anagrams (LeetCodeÂ 49), Valid Sudoku (LeetCodeÂ 36), Intersection of Two Arrays II (LeetCodeÂ 350)
	â€¢	Day 25: 4Sum II (LeetCodeÂ 454), Subarray Sum Equals K (LeetCodeÂ 560), Top K Frequent Elements (LeetCodeÂ 347)
	â€¢	Day 26: Single Number II (LeetCodeÂ 137), Single Number III (LeetCodeÂ 260), Longest Consecutive Sequence (LeetCodeÂ 128)
	â€¢	Day 27: Design HashSet (LeetCodeÂ 705), Design HashMap (LeetCodeÂ 706), Logger Rate Limiter (LeetCodeÂ 359)
	â€¢	Day 28: Majority Element II (LeetCodeÂ 229), Verifying an Alien Dictionary (LeetCodeÂ 953), Uncommon Words from Two Sentences (LeetCodeÂ 884)

(By the end of Month 1, you have covered all fundamental data structures â€“ arrays, strings, linked lists, hash maps/sets â€“ with primarily easy-level problems. We now ramp up to intermediate-level problems in similar topics and new ones. Donâ€™t worry if some problems in week 3â€“4 felt harder; month 2 will reinforce and expand on those concepts.)

Week 5 (Days 29â€“35): Stacks & Queues ğŸ“š (Intermediate â€“ Medium Level)

Theory (Stacks & Queues): A stack is a Last-In-First-Out (LIFO) structure, supporting push and pop operations. In Java, you can use Stack (or better, use Deque to implement stack functionality) for this. Common uses of stacks include parsing bracket expressions, backtracking, and any scenario where you need to reverse or postpone processing (function call stacks, DFS, etc.). A queue is First-In-First-Out (FIFO); Java offers Queue (via LinkedList or ArrayDeque) for implementation. Queues are used in breadth-first search (BFS) algorithms, scheduling tasks, and buffering data streams. This weekâ€™s challenges involve both explicit stack/queue problems (like evaluating expressions, using a stack for min or for reversing data) and implicit uses (like BFS on grids, or sliding window problems using deque). By solving them, youâ€™ll learn when to apply a stack vs. a queue and how to implement these in Java. These are medium-level problems, so expect a step up in logic and complexity (multi-step reasoning, combining data structures, etc.).
	â€¢	Day 29: Valid Parentheses (LeetCodeÂ 20), Min Stack (LeetCodeÂ 155), Implement Queue using Stacks (LeetCodeÂ 232)
	â€¢	Day 30: Implement Stack using Queues (LeetCodeÂ 225), Next Greater Element I (LeetCodeÂ 496), Number of Recent Calls (LeetCodeÂ 933)
	â€¢	Day 31: Daily Temperatures (LeetCodeÂ 739), Evaluate Reverse Polish Notation (LeetCodeÂ 150), Decode String (LeetCodeÂ 394)
	â€¢	Day 32: Asteroid Collision (LeetCodeÂ 735), Simplify Path (LeetCodeÂ 71), Next Greater Element II (LeetCodeÂ 503)
	â€¢	Day 33: Generate Parentheses (LeetCodeÂ 22), Rotting Oranges â€“ Grid BFS (LeetCodeÂ 994), Open the Lock (LeetCodeÂ 752)
	â€¢	Day 34: Sliding Window Maximum (LeetCodeÂ 239), Largest Rectangle in Histogram (LeetCodeÂ 84), Design Circular Queue (LeetCodeÂ 622)
	â€¢	Day 35: Basic Calculator II (LeetCodeÂ 227), Flatten Nested List Iterator (LeetCodeÂ 341), Design Browser History (LeetCodeÂ 1472)

Week 6 (Days 36â€“42): Searching & Sorting ğŸ” (Intermediate â€“ Medium Level)

Theory (Searching & Sorting): Efficient searching and sorting algorithms are fundamental in computer science. This week covers binary search and various sorting-related problems. Binary search is an O(log n) algorithm to find elements in a sorted array by repeatedly dividing the search interval in half. Itâ€™s implemented in Java with loops or recursion, and understanding it is crucial for many problems. Sorting algorithms (like Quick Sort, Merge Sort, etc.) are usually built-in (Arrays.sort() in Java typically uses Dual-Pivot Quicksort for primitives). Many problems reduce to sorting data and then processing it, or using binary search on sorted input or on the answer space. This weekâ€™s tasks include binary search on arrays and on search-space (like finding a minimum capacity or root), as well as interval problems and classic sorting puzzles. Youâ€™ll also solve problems with rotated arrays and the two-pointer pattern for sum problems. By the end of the week, you should solidify knowledge of comparison-based sorting, binary search boundaries, and common algorithmic tricks like two-pointer sweeps on sorted data.
	â€¢	Day 36: Binary Search (LeetCodeÂ 704), First Bad Version (LeetCodeÂ 278), Search Insert Position (LeetCodeÂ 35)
	â€¢	Day 37: Find Peak Element (LeetCodeÂ 162), Find First and Last Position of Element in Sorted Array (LeetCodeÂ 34), Search in Rotated Sorted Array (LeetCodeÂ 33)
	â€¢	Day 38: Find Minimum in Rotated Sorted Array (LeetCodeÂ 153), Kth Largest Element in an Array (LeetCodeÂ 215), 3Sum (LeetCodeÂ 15)
	â€¢	Day 39: 4Sum (LeetCodeÂ 18), Sort Colors (LeetCodeÂ 75), K Closest Points to Origin (LeetCodeÂ 973)
	â€¢	Day 40: Merge Intervals (LeetCodeÂ 56), Insert Interval (LeetCodeÂ 57), Non-overlapping Intervals (LeetCodeÂ 435)
	â€¢	Day 41: Meeting Rooms (LeetCode 252) (Note: from LeetCode Interview archive), Meeting Rooms II (LeetCodeÂ 253), Largest Number (LeetCodeÂ 179)
	â€¢	Day 42: Median of Two Sorted Arrays (LeetCodeÂ 4), Capacity To Ship Packages Within D Days (LeetCodeÂ 1011), Search a 2D Matrix (LeetCodeÂ 74)

Week 7 (Days 43â€“49): Recursion & Backtracking ğŸ”„ (Intermediate â€“ Medium Level)

Theory (Recursion & Backtracking): Recursion is a technique where a function calls itself to solve smaller subproblems. Backtracking is a form of recursion for exploring decision trees (e.g. generating all combinations/permutations, solving puzzles) by trying a move, and undoing it (â€œbacktrackingâ€) if it doesnâ€™t lead to a solution. In Java, be mindful of recursion depth (stack overflow) and use recursion for clarity when it fits (the JVM handles the recursion call stack). This week, youâ€™ll solve problems that naturally use recursion/backtracking: generating subsets, permutations, solving the N-Queens puzzle, etc. Early in the week includes simple recursion (like computing Fibonacci or powers) and DFS (flood fill) to warm up, then moves to combinatorial generation problems (which may be medium difficulty), and finally some challenging backtracking puzzles (like Sudoku solver, expression add operators, etc.). These problems train you to think in terms of state-space search and are frequently seen in interviews (generate combinations) as well as contests (searching all possibilities with pruning).
	â€¢	Day 43: Fibonacci Number (LeetCodeÂ 509), Climbing Stairs (LeetCodeÂ 70) (can be done via recursion or DP), Pow(x, n) â€“ Implement Exponent (LeetCodeÂ 50) ï¿¼
	â€¢	Day 44: Letter Case Permutation (LeetCodeÂ 784), Subsets (LeetCodeÂ 78), Subsets II (LeetCodeÂ 90)
	â€¢	Day 45: Permutations (LeetCodeÂ 46), Permutations II (LeetCodeÂ 47) (permute with duplicates), Combinations (LeetCodeÂ 77)
	â€¢	Day 46: Combination Sum (LeetCodeÂ 39), Combination Sum II (LeetCodeÂ 40), Letter Combinations of a Phone Number (LeetCodeÂ 17)
	â€¢	Day 47: Word Search (LeetCodeÂ 79), Palindrome Partitioning (LeetCodeÂ 131), Restore IP Addresses (LeetCodeÂ 93)
	â€¢	Day 48: N-Queens (LeetCodeÂ 51), Sudoku Solver (LeetCodeÂ 37), N-Queens II â€“ Count Solutions (LeetCodeÂ 52)
	â€¢	Day 49: Gray Code (LeetCodeÂ 89), Expression Add Operators (LeetCodeÂ 282), Remove Invalid Parentheses (LeetCodeÂ 301)

Week 8 (Days 50â€“56): Dynamic Programming ğŸ¤– (Intermediate â€“ Medium/Hard Level)

Theory (Dynamic Programming): Dynamic Programming (DP) is an optimization technique for solving recursive problems more efficiently by storing intermediate results (using memoization or tabulation). If a problem can be broken into overlapping subproblems that follow optimal substructure (the optimal solution can be constructed from optimal solutions of subproblems), DP is often applicable. In Java, you might implement DP with arrays or maps for memoization. This weekâ€™s problems cover classic DP categories: 1D DP (linear sequences like coin change, Fibonacci variants), 2D DP (grid problems, edit distance), subset/knapsack DP (choosing elements under constraints), and sequence DP (subsequence problems). Early days include simpler DP (house robber, coin change) and progress to harder ones (edit distance, scramble string). Pay attention to identifying state and transitions in each problem. These problems will strengthen your ability to optimize naive recursion and are very common in interviews for their complexity and elegance.
	â€¢	Day 50: House Robber (LeetCodeÂ 198), House Robber II (LeetCodeÂ 213), Coin Change (LeetCodeÂ 322)
	â€¢	Day 51: Coin Change 2 (LeetCodeÂ 518), Partition Equal Subset Sum (LeetCodeÂ 416), Min Cost Climbing Stairs (LeetCodeÂ 746)
	â€¢	Day 52: Unique Paths (LeetCodeÂ 62), Unique Paths II (LeetCodeÂ 63), Jump Game (LeetCodeÂ 55)
	â€¢	Day 53: Jump Game II (LeetCodeÂ 45), Decode Ways (LeetCodeÂ 91), Word Break (LeetCodeÂ 139)
	â€¢	Day 54: Longest Increasing Subsequence (LeetCodeÂ 300), Longest Common Subsequence (LeetCodeÂ 1143), Edit Distance (LeetCodeÂ 72)
	â€¢	Day 55: Palindromic Substrings (LeetCodeÂ 647), Longest Palindromic Subsequence (LeetCodeÂ 516), Distinct Subsequences (LeetCodeÂ 115)
	â€¢	Day 56: Interleaving String (LeetCodeÂ 97), Burst Balloons (LeetCodeÂ 312), Scramble String (LeetCodeÂ 87)

(By the end of Month 2, youâ€™ve tackled intermediate topics and some advanced patterns (like DP). The final month will focus on advanced data structures (trees, graphs, tries, heaps) and math-intensive problems (number theory, combinatorics). These weeks will be challenging (mostly hard-level problems), but youâ€™re now prepared with a strong foundation. Remember to revisit earlier problems or theory if you get stuck â€“ the concepts often build on each other.)

Week 9 (Days 57â€“63): Trees ğŸŒ³ (Advanced â€“ Mixed Difficulty)

Theory (Trees): Trees are hierarchical data structures with parent-child relationships. A binary tree is a tree where each node has at most two children (left and right). Important special cases include binary search trees (BSTs), where in-order traversal yields sorted order, and heaps (a kind of tree used for priority queues, covered later). This week focuses on binary trees. Key operations and concepts: depth-first traversals (preorder, inorder, postorder), breadth-first traversal (level order), computing tree height (depth), checking balance (height difference), symmetry, and common ancestor queries. In Java, you might use TreeNode class (with fields for value, left, right). Many problems involve recursion on trees (due to their recursive structure). We start with easy tasks like traversal and insertions, then move to more complex ones like constructing trees from traversals and binary tree algorithms (like finding paths and serialization). By working through these, youâ€™ll gain comfort with recursive algorithms and pointer manipulation, which are crucial for tree manipulations.
	â€¢	Day 57: Binary Tree Inorder Traversal (LeetCodeÂ 94), Binary Tree Preorder Traversal (LeetCodeÂ 144), Binary Tree Postorder Traversal (LeetCodeÂ 145)
	â€¢	Day 58: Maximum Depth of Binary Tree (LeetCodeÂ 104), Symmetric Tree (LeetCodeÂ 101), Invert Binary Tree (LeetCodeÂ 226)
	â€¢	Day 59: Same Tree (LeetCodeÂ 100), Subtree of Another Tree (LeetCodeÂ 572), Balanced Binary Tree (LeetCodeÂ 110)
	â€¢	Day 60: Binary Tree Level Order Traversal (LeetCodeÂ 102), Binary Tree Zigzag Level Order Traversal (LeetCodeÂ 103), Binary Tree Right Side View (LeetCodeÂ 199)
	â€¢	Day 61: Path Sum (LeetCodeÂ 112), Path Sum II (LeetCodeÂ 113), Lowest Common Ancestor of a BST (LeetCodeÂ 235)
	â€¢	Day 62: Validate Binary Search Tree (LeetCodeÂ 98), Lowest Common Ancestor of a Binary Tree (LeetCodeÂ 236), Kth Smallest Element in a BST (LeetCodeÂ 230)
	â€¢	Day 63: Construct Binary Tree from Preorder and Inorder (LeetCodeÂ 105), Serialize and Deserialize Binary Tree (LeetCodeÂ 297), Binary Search Tree Iterator (LeetCodeÂ 173)

Week 10 (Days 64â€“70): Graphs ğŸŒ (Advanced â€“ Medium/Hard Level)

Theory (Graphs): Graphs are a generalization of trees â€“ nodes (vertices) connected by edges (which can be directed or undirected). Many real-world problems are graphs (networks, relationships). Core graph algorithms include Depth-First Search (DFS) and Breadth-First Search (BFS) for traversal, as well as specialized algorithms like Dijkstraâ€™s (shortest path), union-find (disjoint set for connectivity), and topological sort (for DAGs). In Java, graphs can be represented via adjacency lists (e.g. List<List<Integer>> or a Map of node->neighbors). This weekâ€™s problems cover typical graph tasks: counting connected components (islands, provinces), graph traversal (clone graph, BFS puzzles), topological sorting (course schedule), shortest path in unweighted graphs (word ladder, open lock), and even some algorithmic puzzles like finding critical connections or Eulerian paths (reconstruct itinerary). Graph problems are often medium to hard. Tackle them by visualizing the graph, choosing the right approach (DFS, BFS, or union-find), and considering edge cases (cycles, disconnected components). These will also involve combinatorial thinking and sometimes advanced math (but primarily graph theory).
	â€¢	Day 64: Number of Islands (LeetCodeÂ 200), Max Area of Island (LeetCodeÂ 695), Surrounded Regions (LeetCodeÂ 130)
	â€¢	Day 65: Clone Graph (LeetCodeÂ 133), Course Schedule (LeetCodeÂ 207), Course Schedule II (LeetCodeÂ 210)
	â€¢	Day 66: Pacific Atlantic Water Flow (LeetCodeÂ 417), 01 Matrix (LeetCodeÂ 542), Is Graph Bipartite? (LeetCodeÂ 785)
	â€¢	Day 67: Word Ladder (LeetCodeÂ 127), Word Ladder II (LeetCodeÂ 126), Shortest Path in Binary Matrix (LeetCodeÂ 1091)
	â€¢	Day 68: Network Delay Time (LeetCodeÂ 743), Minimum Knight Moves (LeetCodeÂ 1197), All Paths From Source to Target (LeetCodeÂ 797)
	â€¢	Day 69: Redundant Connection (LeetCodeÂ 684), Number of Provinces (LeetCodeÂ 547), Critical Connections in a Network (LeetCodeÂ 1192)
	â€¢	Day 70: Reconstruct Itinerary (LeetCodeÂ 332), Graph Valid Tree (LeetCode 261) (LeetCode Interview archive), Alien Dictionary (LeetCodeÂ 269) (hard â€“ derive ordering of letters via topological sort)

Week 11 (Days 71â€“77): Mathematics & Bit Manipulation ğŸ”¢ (Advanced â€“ Mixed Difficulty)

Theory (Math & Bit Manipulation): Many programming challenges involve mathematical reasoning or bitwise operations. Number theory topics include prime numbers, greatest common divisor (GCD), modular arithmetic, etc., which are frequently asked in competitive programming ï¿¼. Combinatorics (counting) is covered next week, so this week leans more on pure math and bits. Bit manipulation leverages binary representations of numbers; in Java, you have bitwise operators (&, |, ^, ~, <<, >>). Common tasks: counting set bits, checking power of 2, flipping bits, etc. We also include some classical math problems like checking primes, computing GCD/LCM, and simple simulation of math operations (like division without using divide). This weekâ€™s problems range from easy one-liners (e.g., parity checks) to tricky bit problems (like range bitwise AND) and math puzzles (like happy number or prime counting). They develop your low-level understanding of data and are often the key to optimizing algorithms (bit tricks can replace loops). Competitive programmers place heavy emphasis on number theory and bit tricks ï¿¼ ï¿¼, so mastering these will give you an edge.
	â€¢	Day 71: Count Primes (LeetCodeÂ 204), Greatest Common Divisor of Strings (LeetCodeÂ 1071), Power of Two (LeetCodeÂ 231)
	â€¢	Day 72: Power of Three (LeetCodeÂ 326), Power of Four (LeetCodeÂ 342), Sqrt(x) â€“ Integer Square Root (LeetCodeÂ 69)
	â€¢	Day 73: Factorial Trailing Zeroes (LeetCodeÂ 172), Ugly Number (LeetCodeÂ 263), Arranging Coins (LeetCodeÂ 441)
	â€¢	Day 74: Number of 1 Bits (LeetCodeÂ 191) (Hamming Weight), Hamming Distance (LeetCodeÂ 461), Reverse Bits (LeetCodeÂ 190)
	â€¢	Day 75: Sum of Two Integers (LeetCodeÂ 371) (bitwise addition), Bitwise AND of Numbers Range (LeetCodeÂ 201), Counting Bits (LeetCodeÂ 338)
	â€¢	Day 76: Watermelon (CodeForcesÂ 4A), Elephant (CodeForcesÂ 617A), Bear and Big Brother (CodeForcesÂ 791A)
	â€¢	Day 77: Wrong Subtraction (CodeForcesÂ 977A), Nearly Lucky Number (CodeForcesÂ 110A), Hit the Lottery (CodeForcesÂ 996A)

Week 12 (Days 78â€“84): Combinatorics ğŸ² (Advanced â€“ Mixed Difficulty)

Theory (Combinatorics & Counting): Combinatorics deals with counting combinations, permutations, and arrangements of sets â€“ a core part of discrete mathematics and competitive programming ï¿¼. Many problems reduce to computing the number of ways to do something (with or without dynamic programming). This weekâ€™s focus is on counting and generating combinations/permutations and other combinatorial constructs. Youâ€™ll practice with Pascalâ€™s Triangle (which relates to binomial coefficients), permutation generation and ordering (next permutation, kth permutation), and some creative counting problems (like counting unique digit numbers, or vowel permutations with rules). We also include a few CodeForces problems that involve simple combinatorial reasoning (like counting team solutions or using division results). These tasks reinforce understanding of mathematical patterns and often require recognizing formulae (nCr, Catalan numbers, etc.) or using backtracking with pruning to count possibilities. By the end, you should be comfortable with both constructing combinations (backtracking approach) and computing counts via formulas or DP.
	â€¢	Day 78: Pascalâ€™s Triangle (LeetCodeÂ 118), Pascalâ€™s Triangle II (LeetCodeÂ 119), Unique Binary Search Trees (LeetCodeÂ 96) (Catalan number application)
	â€¢	Day 79: Next Permutation (LeetCodeÂ 31), Permutation Sequence (LeetCodeÂ 60), Count Numbers with Unique Digits (LeetCodeÂ 357)
	â€¢	Day 80: Bulb Switcher (LeetCodeÂ 319), Letter Tile Possibilities (LeetCodeÂ 1079), Beautiful Arrangement (LeetCodeÂ 526)
	â€¢	Day 81: Count Vowels Permutation (LeetCodeÂ 1220), Number of Dice Rolls with Target Sum (LeetCodeÂ 1155), Combination Sum IV (LeetCodeÂ 377)
	â€¢	Day 82: Team (CodeForcesÂ 231A), Soft Drinking (CodeForcesÂ 151A), George and Accommodation (CodeForcesÂ 467A)
	â€¢	Day 83: Domino Piling (CodeForcesÂ 50A), Beautiful Matrix (CodeForcesÂ 263A), Petya and Strings (CodeForcesÂ 112A)
	â€¢	Day 84: Soldier and Bananas (CodeForcesÂ 546A), Anton and Danik (CodeForcesÂ 734A), Ultra-Fast Mathematician (CodeForcesÂ 61A)

Week 13 (Days 85â€“90): Advanced Topics (Heaps, Tries, & More) ğŸ§©

Theory (Heaps, Tries & Advanced Data Structures): In this final week, we tackle a few remaining advanced structures and problem types:
	â€¢	Heaps/Priority Queues: A heap is a complete binary tree satisfying the heap property (max-heap or min-heap). In Java, use PriorityQueue. Heaps allow efficient retrieval of the largest or smallest element. Many problems (like â€œtop Kâ€ or â€œmerge sorted listsâ€) utilize heaps for optimal performance.
	â€¢	Tries (Prefix Trees): A trie is a tree-based structure for storing strings by their prefixes. Each node represents a prefix of some words. Tries are useful for fast prefix queries (autocomplete, spell-check, word games). Weâ€™ll implement tries and apply them to problems like word search optimization and prefix/suffix lookups.
	â€¢	Advanced design problems: We include LRU/LFU Cache designs â€“ these require using multiple structures (lists + hash maps) to achieve the desired performance. These are often considered hard due to careful detail management.
	â€¢	Miscellaneous algorithms: e.g., a hard problem like â€œTrapping Rain Waterâ€ (two-pointer or stack solution) as a final challenge.

This weekâ€™s tasks are among the toughest (mostly hard level). They will test your understanding of all earlier concepts combined with new ones. Donâ€™t be discouraged by difficulty â€“ even if you can outline a solution or solve part of the problem, thatâ€™s progress. Use this week to identify any weak spots to review. Solving these will give you confidence in tackling virtually any coding problem.
	â€¢	Day 85: Kth Largest Element in a Stream (LeetCodeÂ 703), Last Stone Weight (LeetCodeÂ 1046), Kth Smallest Element in a Sorted Matrix (LeetCodeÂ 378)
	â€¢	Day 86: Find Median from Data Stream (LeetCodeÂ 295), Sliding Window Median (LeetCodeÂ 480), Merge K Sorted Lists (LeetCodeÂ 23)
	â€¢	Day 87: Trapping Rain Water (LeetCodeÂ 42), Task Scheduler (LeetCodeÂ 621), LRU Cache (LeetCodeÂ 146)
	â€¢	Day 88: Implement Trie (Prefix Tree) (LeetCodeÂ 208), Add and Search Word â€“ Data structure design (LeetCodeÂ 211), Word Search II (LeetCodeÂ 212)
	â€¢	Day 89: Replace Words (LeetCodeÂ 648), Maximum XOR of Two Numbers in an Array (LeetCodeÂ 421), LFU Cache (LeetCodeÂ 460)
	â€¢	Day 90: Prefix and Suffix Search (LeetCodeÂ 745), Design Search Autocomplete System (LeetCodeÂ 642), Palindrome Pairs (LeetCodeÂ 336)

â¸»

Conclusion & Next Steps: Congratulations on making it through 90 days of intensive practice! ğŸ‰ Youâ€™ve solved around 270 problems across all major topics in computer science: data structures (arrays, linked lists, stacks, queues, trees, graphs, tries), algorithms (sorting, searching, DP, backtracking, etc.), and mathematics (number theory, combinatorics, bit manipulation). This roadmap was designed to build your skills from the ground up â€“ from basic problem-solving to tackling some of the toughest coding challenges. Along the way, youâ€™ve learned to analyze problems, recognize patterns, and apply appropriate techniques (often combining multiple concepts).

Going forward, you can reinforce knowledge by revisiting problems you found difficult, or by exploring variations of these problems. Itâ€™s also beneficial to participate in contests (LeetCode weekly contests or Codeforces rounds) to apply what youâ€™ve learned under time pressure. Continue to write clean, well-documented code and perhaps contribute your solutions and insights (e.g., as blog posts or in discussion forums) â€“ this helps solidify your understanding and gives back to the community.

Remember that consistency and curiosity are key in programming. By following this guide, youâ€™ve built a strong foundation. Keep practicing and exploring new challenges beyond this 90-day plan to become even more proficient. Good luck, and happy coding! ğŸ¤—

Sources & References: This plan was informed by popular coding interview problem sets (like LeetCode Top Interview questions and NeetCode 150) and competitive programming problem archives. For theoretical groundwork, references like GeeksforGeeks and others were used to ensure coverage of important topics (e.g., the significance of arrays ï¿¼, and the common categories in contests ï¿¼). The structured approach of easy->medium->hard over 3 months is a proven strategy in many DSA roadmaps ï¿¼ ï¿¼. Additionally, number theory and combinatorics were emphasized because they are frequently asked in contests ï¿¼. All problem statements belong to their respective platforms (LeetCode, CodeForces, etc.), and you can find detailed editorial solutions on those sites or community forums if you need hints. Stay persistent â€“ with the completion of this roadmap, you are well on your way to algorithmic mastery! ï¿¼ ï¿¼
